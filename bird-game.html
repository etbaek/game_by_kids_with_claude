<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìƒˆ ê²Œì„ - Bird Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        canvas { max-width: 100%; height: auto; }

        @media (max-width: 520px) {
            h1 { font-size: 1.5rem; }
            .stats { gap: 15px; }
            .stat { padding: 8px 15px; }
            .stat-value { font-size: 1.2rem; }
            .instructions { font-size: 0.75rem; }
            .back-btn { padding: 8px 12px; font-size: 0.75rem; top: 10px; left: 10px; }
        }

        .game-container {
            text-align: center;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 10px;
            color: #fff;
            font-size: 1.2rem;
        }

        .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .feathers .stat-value {
            color: #ffd700;
        }

        .score .stat-value {
            color: #00ff88;
        }

        canvas {
            border: 3px solid #4a4a6a;
            border-radius: 10px;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 100%);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
        }

        .game-over h2 {
            color: #ff4444;
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        .game-over p {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            font-size: 0.9rem;
            border-radius: 25px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s;
            z-index: 1000;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .restart-btn {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        .restart-btn:hover {
            background: #00cc6a;
            transform: scale(1.05);
        }

        .instructions {
            color: #888;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        /* ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ */
        .touch-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        @media (max-width: 800px) {
            .touch-controls { display: block; }
            .instructions { display: none; }
        }

        .touch-pad {
            position: relative;
            width: 150px;
            height: 150px;
        }

        .touch-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #fff;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.5);
        }

        .touch-btn.up { top: 0; left: 50px; }
        .touch-btn.down { bottom: 0; left: 50px; }
        .touch-btn.left { top: 50px; left: 0; }
        .touch-btn.right { top: 50px; right: 0; }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">ğŸ  ë‹¤ë¥¸ ê²Œì„ í•˜ê¸°</a>
    <div class="game-container">
        <h1>ğŸ¦ ìƒˆ ê²Œì„</h1>
        <div class="stats">
            <div class="stat feathers">
                <div class="stat-label">ê¹ƒí„¸</div>
                <div class="stat-value" id="feathers">30</div>
            </div>
            <div class="stat score">
                <div class="stat-label">ì ìˆ˜</div>
                <div class="stat-value" id="score">0</div>
            </div>
        </div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <p class="instructions">â¬†ï¸â¬‡ï¸â¬…ï¸â¡ï¸ ë°©í–¥í‚¤ ë˜ëŠ” ğŸ–±ï¸ ë§ˆìš°ìŠ¤ë¡œ ìƒˆë¥¼ ì›€ì§ì´ì„¸ìš”!</p>
        <p class="instructions" style="margin-top: 5px;">ğŸ’› ë…¸ë€ ì”¨ì•— = ì ìˆ˜ +10 | ğŸ’– ë¶„í™ í•˜íŠ¸ = ê¹ƒí„¸ +1</p>

        <div class="game-over" id="gameOver">
            <h2>ê²Œì„ ì˜¤ë²„!</h2>
            <p>ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span></p>
            <button class="restart-btn" onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <!-- ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ -->
    <div class="touch-controls">
        <div class="touch-pad">
            <div class="touch-btn up" id="btnUp">â¬†ï¸</div>
            <div class="touch-btn down" id="btnDown">â¬‡ï¸</div>
            <div class="touch-btn left" id="btnLeft">â¬…ï¸</div>
            <div class="touch-btn right" id="btnRight">â¡ï¸</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ê²Œì„ ìƒíƒœ
        let gameRunning = true;
        let feathers = 30;
        let score = 0;

        // ìƒˆ (í”Œë ˆì´ì–´)
        const bird = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            width: 40,
            height: 40,
            speed: 5,
            dx: 0,
            dy: 0
        };

        // ë¨¹ì´ ë°°ì—´
        let foods = [];

        // ì¥ì• ë¬¼ ë°°ì—´
        let obstacles = [];

        // í‚¤ ìƒíƒœ
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // ë§ˆìš°ìŠ¤ ìƒíƒœ
        let mouseTarget = null;
        let useMouseControl = false;

        // í‚¤ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                useMouseControl = false;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseTarget = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            useMouseControl = true;
        });

        canvas.addEventListener('mouseleave', () => {
            useMouseControl = false;
        });

        // ëª¨ë°”ì¼ í„°ì¹˜ ë²„íŠ¼ ì´ë²¤íŠ¸
        function setupTouchButton(btnId, key) {
            const btn = document.getElementById(btnId);
            if (!btn) return;

            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
                useMouseControl = false;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
            btn.addEventListener('touchcancel', () => {
                keys[key] = false;
            });
            // ë§ˆìš°ìŠ¤ë„ ì§€ì›
            btn.addEventListener('mousedown', () => {
                keys[key] = true;
                useMouseControl = false;
            });
            btn.addEventListener('mouseup', () => {
                keys[key] = false;
            });
            btn.addEventListener('mouseleave', () => {
                keys[key] = false;
            });
        }

        setupTouchButton('btnUp', 'ArrowUp');
        setupTouchButton('btnDown', 'ArrowDown');
        setupTouchButton('btnLeft', 'ArrowLeft');
        setupTouchButton('btnRight', 'ArrowRight');

        // ë¨¹ì´ ìƒì„± - ë‘ ì¢…ë¥˜
        function spawnFood() {
            if (foods.length < 6) {
                // 50% í™•ë¥ ë¡œ ì ìˆ˜ ë¨¹ì´ ë˜ëŠ” ê¹ƒí„¸ ë¨¹ì´
                const isScoreFood = Math.random() > 0.5;

                foods.push({
                    x: Math.random() * (canvas.width - 30) + 15,
                    y: Math.random() * (canvas.height - 30) + 15,
                    radius: 12,
                    type: isScoreFood ? 'score' : 'feather',
                    color: isScoreFood ? '#FFD700' : '#FF69B4'
                });
            }
        }

        // ì¥ì• ë¬¼ ìƒì„±
        function spawnObstacle() {
            if (obstacles.length < 8) {
                const side = Math.floor(Math.random() * 4);
                let x, y, dx, dy;

                switch(side) {
                    case 0: // ìœ„ì—ì„œ
                        x = Math.random() * canvas.width;
                        y = -30;
                        dx = (Math.random() - 0.5) * 2;
                        dy = Math.random() * 2 + 1;
                        break;
                    case 1: // ì•„ë˜ì—ì„œ
                        x = Math.random() * canvas.width;
                        y = canvas.height + 30;
                        dx = (Math.random() - 0.5) * 2;
                        dy = -(Math.random() * 2 + 1);
                        break;
                    case 2: // ì™¼ìª½ì—ì„œ
                        x = -30;
                        y = Math.random() * canvas.height;
                        dx = Math.random() * 2 + 1;
                        dy = (Math.random() - 0.5) * 2;
                        break;
                    case 3: // ì˜¤ë¥¸ìª½ì—ì„œ
                        x = canvas.width + 30;
                        y = Math.random() * canvas.height;
                        dx = -(Math.random() * 2 + 1);
                        dy = (Math.random() - 0.5) * 2;
                        break;
                }

                obstacles.push({
                    x: x,
                    y: y,
                    width: 35,
                    height: 35,
                    dx: dx,
                    dy: dy
                });
            }
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function checkCircleCollision(rect, circle) {
            const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
            const distanceX = circle.x - closestX;
            const distanceY = circle.y - closestY;
            return (distanceX * distanceX + distanceY * distanceY) < (circle.radius * circle.radius);
        }

        // ê¼¬ë¦¬ ê¹ƒí„¸ ê·¸ë¦¬ê¸°
        function drawTailFeathers() {
            ctx.save();
            // ìƒˆì˜ ê¼¬ë¦¬ ìœ„ì¹˜ (ëª¸í†µ ì™¼ìª½ ë)
            ctx.translate(bird.x + bird.width / 2 - 18, bird.y + bird.height / 2);

            const maxFeathers = 30;
            const currentFeathers = feathers;

            // ê¹ƒí„¸ì„ ë¶€ì±„ê¼´ë¡œ ë°°ì¹˜ (ìœ„ì•„ë˜ë¡œ í¼ì¹¨, ì™¼ìª½ ë°©í–¥)
            const spreadAngle = Math.PI * 0.6; // ìœ„ì•„ë˜ í¼ì¹¨ ê°ë„
            const startAngle = -spreadAngle / 2; // ìœ„ìª½ë¶€í„° ì‹œì‘

            for (let i = 0; i < currentFeathers; i++) {
                // ìœ„ì—ì„œ ì•„ë˜ë¡œ ìˆœì„œëŒ€ë¡œ ë°°ì¹˜
                const angle = startAngle + (spreadAngle * i) / (maxFeathers - 1);

                // ê°€ìš´ë° ê¹ƒí„¸ì´ ë” ê¸¸ê³ , ìœ„ì•„ë˜ëŠ” ì§§ê²Œ
                const distFromCenter = Math.abs(i - (maxFeathers - 1) / 2);
                const featherLength = 35 - distFromCenter * 0.8;

                // ìƒ‰ìƒ ê·¸ë¼ë°ì´ì…˜ (ë…¸ë‘ -> ì£¼í™© -> ë¹¨ê°•)
                const hue = 50 - (i / maxFeathers) * 25;
                const saturation = 95;
                const lightness = 55 + (i % 3) * 3;

                ctx.save();
                ctx.rotate(angle);

                // ê¹ƒí„¸ì„ ì™¼ìª½(-x)ìœ¼ë¡œ ê·¸ë¦¼
                const startX = 0;
                const endX = -featherLength;

                // ê¹ƒí„¸ ì¤„ê¸°
                ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness - 20}%)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(startX, 0);
                ctx.lineTo(endX, 0);
                ctx.stroke();

                // ê¹ƒí„¸ ë³¸ì²´ (íƒ€ì›í˜•)
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                ctx.beginPath();
                ctx.ellipse(endX / 2, 0, featherLength / 2, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // ê¹ƒí„¸ í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = `hsla(60, 100%, 85%, 0.5)`;
                ctx.beginPath();
                ctx.ellipse(endX / 2 - 3, -1, featherLength / 4, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            ctx.restore();
        }

        // ìƒˆ ê·¸ë¦¬ê¸°
        function drawBird() {
            // ë¨¼ì € ê¼¬ë¦¬ ê¹ƒí„¸ ê·¸ë¦¬ê¸° (ìƒˆ ëª¸í†µ ë’¤ì—)
            drawTailFeathers();

            ctx.save();
            ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);

            // ëª¸í†µ
            ctx.fillStyle = '#FFD93D';
            ctx.beginPath();
            ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // ë‚ ê°œ
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.ellipse(-5, 5, 12, 8, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            // ë¨¸ë¦¬
            ctx.fillStyle = '#FFD93D';
            ctx.beginPath();
            ctx.arc(15, -5, 12, 0, Math.PI * 2);
            ctx.fill();

            // ëˆˆ
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(18, -7, 3, 0, Math.PI * 2);
            ctx.fill();

            // ëˆˆ ë°˜ì§ì„
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(19, -8, 1, 0, Math.PI * 2);
            ctx.fill();

            // ë¶€ë¦¬
            ctx.fillStyle = '#FF6B35';
            ctx.beginPath();
            ctx.moveTo(25, -5);
            ctx.lineTo(32, -3);
            ctx.lineTo(25, 0);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // ë¨¹ì´ ê·¸ë¦¬ê¸°
        function drawFoods() {
            foods.forEach(food => {
                if (food.type === 'score') {
                    // ë…¸ë€ ì”¨ì•— (ì ìˆ˜)
                    ctx.fillStyle = food.color;
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, food.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // ë°˜ì§ì„
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(food.x - 4, food.y - 4, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // ë¶„í™ í•˜íŠ¸ (ê¹ƒí„¸ íšŒë³µ)
                    ctx.fillStyle = food.color;
                    ctx.beginPath();
                    const x = food.x;
                    const y = food.y;
                    const size = food.radius;
                    ctx.moveTo(x, y + size / 4);
                    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 4);
                    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.2, x, y + size * 1.2);
                    ctx.bezierCurveTo(x, y + size * 1.2, x + size, y + size, x + size, y + size / 4);
                    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y + size / 4);
                    ctx.fill();

                    // í•˜íŠ¸ ë°˜ì§ì„
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(x - 5, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸°
        function drawObstacles() {
            obstacles.forEach(obs => {
                // ë°”ìœ„ ëª¨ì–‘
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(obs.x + obs.width / 2, obs.y);
                ctx.lineTo(obs.x + obs.width, obs.y + obs.height * 0.7);
                ctx.lineTo(obs.x + obs.width * 0.8, obs.y + obs.height);
                ctx.lineTo(obs.x + obs.width * 0.2, obs.y + obs.height);
                ctx.lineTo(obs.x, obs.y + obs.height * 0.6);
                ctx.closePath();
                ctx.fill();

                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = '#777';
                ctx.beginPath();
                ctx.moveTo(obs.x + obs.width / 2, obs.y + 5);
                ctx.lineTo(obs.x + obs.width * 0.7, obs.y + obs.height * 0.5);
                ctx.lineTo(obs.x + obs.width / 2, obs.y + obs.height * 0.6);
                ctx.lineTo(obs.x + obs.width * 0.3, obs.y + obs.height * 0.4);
                ctx.closePath();
                ctx.fill();
            });
        }

        // ê¹ƒí„¸ ì´í™íŠ¸
        let fallingFeathers = [];

        function createFeatherEffect(x, y) {
            // ê¼¬ë¦¬ ìª½ì—ì„œ ê¹ƒí„¸ì´ ë¹ ì§€ëŠ” íš¨ê³¼ (ì™¼ìª½ì—ì„œ)
            for (let i = 0; i < 3; i++) {
                const hue = 40 + Math.random() * 15;
                fallingFeathers.push({
                    x: x - 20 - Math.random() * 15,
                    y: y + (Math.random() - 0.5) * 20,
                    dx: -Math.random() * 2 - 1,
                    dy: Math.random() * -2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3,
                    alpha: 1,
                    length: 12 + Math.random() * 8,
                    color: `hsl(${hue}, 95%, 55%)`
                });
            }
        }

        function drawFallingFeathers() {
            fallingFeathers.forEach((f, index) => {
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.rotation);
                ctx.globalAlpha = f.alpha;

                // ê¹ƒí„¸ ì¤„ê¸°
                ctx.strokeStyle = f.color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-f.length / 2, 0);
                ctx.lineTo(f.length / 2, 0);
                ctx.stroke();

                // ê¹ƒí„¸ ë³¸ì²´
                ctx.fillStyle = f.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, f.length / 2, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255, 255, 200, 0.4)';
                ctx.beginPath();
                ctx.ellipse(-2, -1, f.length / 4, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ (í”ë“¤ë¦¬ë©° ë–¨ì–´ì§)
                f.x += f.dx;
                f.y += f.dy;
                f.dy += 0.08;
                f.dx += Math.sin(f.rotation) * 0.1;
                f.rotation += f.rotationSpeed;
                f.alpha -= 0.015;

                if (f.alpha <= 0) {
                    fallingFeathers.splice(index, 1);
                }
            });
        }

        // ì—…ë°ì´íŠ¸
        function update() {
            if (!gameRunning) return;

            // ë§ˆìš°ìŠ¤ ì¡°ì‘
            if (useMouseControl && mouseTarget) {
                const centerX = bird.x + bird.width / 2;
                const centerY = bird.y + bird.height / 2;
                const dx = mouseTarget.x - centerX;
                const dy = mouseTarget.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) {
                    bird.x += (dx / distance) * bird.speed;
                    bird.y += (dy / distance) * bird.speed;
                }
            }

            // í‚¤ë³´ë“œ ì¡°ì‘
            if (keys.ArrowUp) bird.y -= bird.speed;
            if (keys.ArrowDown) bird.y += bird.speed;
            if (keys.ArrowLeft) bird.x -= bird.speed;
            if (keys.ArrowRight) bird.x += bird.speed;

            // ê²½ê³„ ì²´í¬
            bird.x = Math.max(0, Math.min(canvas.width - bird.width, bird.x));
            bird.y = Math.max(0, Math.min(canvas.height - bird.height, bird.y));

            // ì¥ì• ë¬¼ ì´ë™
            obstacles.forEach((obs, index) => {
                obs.x += obs.dx;
                obs.y += obs.dy;

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
                if (obs.x < -50 || obs.x > canvas.width + 50 ||
                    obs.y < -50 || obs.y > canvas.height + 50) {
                    obstacles.splice(index, 1);
                }
            });

            // ë¨¹ì´ ì¶©ëŒ
            foods.forEach((food, index) => {
                if (checkCircleCollision(bird, food)) {
                    foods.splice(index, 1);

                    if (food.type === 'score') {
                        // ì ìˆ˜ ë¨¹ì´: ì ìˆ˜ë§Œ íšë“
                        score += 10;
                    } else {
                        // ê¹ƒí„¸ ë¨¹ì´: ê¹ƒí„¸ë§Œ íšŒë³µ
                        if (feathers < 30) feathers++;
                    }
                    updateUI();
                }
            });

            // ì¥ì• ë¬¼ ì¶©ëŒ
            obstacles.forEach((obs, index) => {
                if (checkCollision(bird, obs)) {
                    obstacles.splice(index, 1);
                    feathers--;
                    createFeatherEffect(bird.x + bird.width / 2, bird.y + bird.height / 2);
                    updateUI();

                    if (feathers <= 0) {
                        gameOver();
                    }
                }
            });
        }

        // UI ì—…ë°ì´íŠ¸
        function updateUI() {
            document.getElementById('feathers').textContent = feathers;
            document.getElementById('score').textContent = score;
        }

        // ê²Œì„ ì˜¤ë²„
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        // ê²Œì„ ì¬ì‹œì‘
        function restartGame() {
            gameRunning = true;
            feathers = 30;
            score = 0;
            bird.x = canvas.width / 2;
            bird.y = canvas.height / 2;
            foods = [];
            obstacles = [];
            fallingFeathers = [];
            mouseTarget = null;
            useMouseControl = false;
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }

        // ê·¸ë¦¬ê¸°
        function draw() {
            // ë°°ê²½
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // êµ¬ë¦„
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(100, 80, 30, 0, Math.PI * 2);
            ctx.arc(130, 70, 35, 0, Math.PI * 2);
            ctx.arc(160, 80, 30, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(600, 120, 25, 0, Math.PI * 2);
            ctx.arc(625, 110, 30, 0, Math.PI * 2);
            ctx.arc(655, 115, 28, 0, Math.PI * 2);
            ctx.fill();

            drawFoods();
            drawObstacles();
            drawBird();
            drawFallingFeathers();
        }

        // ê²Œì„ ë£¨í”„
        let lastFoodSpawn = 0;
        let lastObstacleSpawn = 0;

        function gameLoop(timestamp) {
            update();
            draw();

            // ë¨¹ì´ ìƒì„± (2ì´ˆë§ˆë‹¤)
            if (timestamp - lastFoodSpawn > 2000) {
                spawnFood();
                lastFoodSpawn = timestamp;
            }

            // ì¥ì• ë¬¼ ìƒì„± (1.5ì´ˆë§ˆë‹¤)
            if (timestamp - lastObstacleSpawn > 1500) {
                spawnObstacle();
                lastObstacleSpawn = timestamp;
            }

            requestAnimationFrame(gameLoop);
        }

        // ì´ˆê¸° ë¨¹ì´ ìƒì„±
        for (let i = 0; i < 3; i++) {
            spawnFood();
        }

        // ê²Œì„ ì‹œì‘
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
