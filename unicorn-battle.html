<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="touch-action" content="manipulation">
    <title>Unicorn Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        .nav-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            text-decoration: none;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 100;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
        }

        /* Character Select Screen */
        .select-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 20px;
        }

        .select-screen.hidden {
            display: none;
        }

        .select-title {
            font-size: 2.5rem;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            margin-bottom: 30px;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            max-width: 500px;
            margin-bottom: 30px;
        }

        .character-card {
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .character-card:hover {
            transform: scale(1.05);
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .character-card.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .char-icon {
            font-size: 50px;
            margin-bottom: 10px;
        }

        .char-name {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .char-desc {
            color: #888;
            font-size: 11px;
            margin-top: 5px;
        }

        .start-btn {
            padding: 15px 50px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }

        .game-header {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 10;
        }

        .health-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-bar {
            width: 150px;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .health-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 15px;
        }

        .player-health .health-fill {
            background: linear-gradient(90deg, #ff9ff3, #f368e0);
        }

        .enemy-health .health-fill {
            background: linear-gradient(90deg, #ff6b6b, #ee5a24);
        }

        .character-icon {
            font-size: 30px;
        }

        .player-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .vs-text {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #gameCanvas {
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }

        .control-group {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
        }

        .attack-btn {
            width: 60px;
            height: 60px;
            font-size: 22px;
        }

        .attack1 {
            background: linear-gradient(135deg, #ff9ff3, #f368e0);
            border-color: #ff9ff3;
        }

        .attack2 {
            background: linear-gradient(135deg, #54a0ff, #2e86de);
            border-color: #54a0ff;
        }

        .attack3 {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            border-color: #ff6b6b;
        }

        .cooldown {
            opacity: 0.4;
            pointer-events: none;
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .game-over-screen.show {
            display: flex;
        }

        .result-icon {
            font-size: 100px;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .result-text {
            font-size: 48px;
            font-weight: bold;
            color: white;
            margin-bottom: 30px;
            text-shadow: 0 0 20px currentColor;
        }

        .result-text.win {
            color: #ffd700;
        }

        .result-text.lose {
            color: #ff6b6b;
        }

        .restart-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }

        .combo-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            opacity: 0;
            z-index: 50;
        }

        .combo-display.show {
            animation: comboPopup 0.5s ease-out;
        }

        @keyframes comboPopup {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        @media (max-width: 600px) {
            .health-bar {
                width: 100px;
            }
            .character-icon {
                font-size: 24px;
            }
            .vs-text {
                font-size: 18px;
            }
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
            .attack-btn {
                width: 55px;
                height: 55px;
                font-size: 18px;
            }
            .select-title {
                font-size: 1.8rem;
            }
            .character-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            .char-icon {
                font-size: 40px;
            }
            .char-name {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="nav-btn">üè† Îã§Î•∏ Í≤åÏûÑ</a>

    <!-- Character Select Screen -->
    <div class="select-screen" id="selectScreen">
        <h1 class="select-title">Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù</h1>
        <div class="character-grid" id="characterGrid"></div>
        <button class="start-btn" onclick="startGame()">ÎåÄÍ≤∞ ÏãúÏûë!</button>
    </div>

    <div class="game-header" id="gameHeader" style="display: none;">
        <div class="health-container">
            <span class="character-icon" id="playerIcon">ü¶Ñ</span>
            <div>
                <div class="player-label">YOU</div>
                <div class="health-bar player-health">
                    <div class="health-fill" id="playerHealth" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <span class="vs-text">VS</span>

        <div class="health-container">
            <div style="text-align: right;">
                <div class="player-label">AI</div>
                <div class="health-bar enemy-health">
                    <div class="health-fill" id="enemyHealth" style="width: 100%"></div>
                </div>
            </div>
            <span class="character-icon" id="enemyIcon">üëø</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="controls" id="controls" style="display: none;">
        <div class="control-group">
            <button class="control-btn" id="leftBtn">‚óÄ</button>
            <button class="control-btn" id="rightBtn">‚ñ∂</button>
            <button class="control-btn" id="jumpBtn">‚ñ≤</button>
        </div>
        <div class="control-group">
            <button class="control-btn attack-btn attack1" id="attack1Btn">‚öîÔ∏è</button>
            <button class="control-btn attack-btn attack2" id="attack2Btn">üí´</button>
            <button class="control-btn attack-btn attack3" id="attack3Btn">üí•</button>
        </div>
    </div>

    <div class="combo-display" id="comboDisplay"></div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="result-icon" id="resultIcon">ü¶Ñ</div>
        <div class="result-text" id="resultText">Victory!</div>
        <button class="restart-btn" onclick="restartGame()">Îã§Ïãú Ïã∏Ïö∞Í∏∞</button>
        <button class="restart-btn" onclick="backToSelect()">Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Characters data
        const characters = [
            { id: 'unicorn', name: 'Ïú†ÎãàÏΩò', icon: 'ü¶Ñ', desc: 'Í∑†ÌòïÏû°Ìûå Í∏∞Î≥∏ Ï∫êÎ¶≠ÌÑ∞', color: '#ff9ff3', attack1: '‚ú®', attack2: 'üåü', attack3: 'üåà' },
            { id: 'demon', name: 'ÏïÖÎßà Ïú†ÎãàÏΩò', icon: 'ü¶Ñ', desc: 'Í∞ïÌïú Í≥µÍ≤©, ÎäêÎ¶∞ ÏÜçÎèÑ', color: '#dc2626', attack1: 'üî•', attack2: 'üíÄ', attack3: '‚ò†Ô∏è', overlay: 'üòà' },
            { id: 'angel', name: 'Ï≤úÏÇ¨ Ïú†ÎãàÏΩò', icon: 'ü¶Ñ', desc: 'Îπ†Î•∏ ÏÜçÎèÑ, ÌöåÎ≥µÎ†•', color: '#ffd700', attack1: '‚ö°', attack2: 'üëº', attack3: '‚úùÔ∏è', overlay: 'üòá' },
            { id: 'ice', name: 'ÏñºÏùå Ïú†ÎãàÏΩò', icon: 'ü¶Ñ', desc: 'Ïä¨Î°úÏö∞ Ìö®Í≥º', color: '#54a0ff', attack1: '‚ùÑÔ∏è', attack2: 'üßä', attack3: 'üíé', overlay: 'ü•∂' },
            { id: 'fire', name: 'Î∂àÍΩÉ Ïú†ÎãàÏΩò', icon: 'ü¶Ñ', desc: 'ÌôîÏÉÅ Îç∞ÎØ∏ÏßÄ', color: '#ff6b6b', attack1: 'üî•', attack2: '‚òÑÔ∏è', attack3: 'üåã', overlay: 'üî•' },
            { id: 'shadow', name: 'Í∑∏Î¶ºÏûê Ïú†ÎãàÏΩò', icon: 'ü¶Ñ', desc: 'ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•† Ï¶ùÍ∞Ä', color: '#6c5ce7', attack1: 'üåë', attack2: 'üëÅÔ∏è', attack3: 'üåÄ', overlay: 'üë§' }
        ];

        let selectedCharacter = characters[0];
        let enemyCharacter = null;

        // Create character select grid
        const grid = document.getElementById('characterGrid');
        characters.forEach((char, index) => {
            const card = document.createElement('div');
            card.className = 'character-card' + (index === 0 ? ' selected' : '');
            card.innerHTML = `
                <div class="char-icon" style="position: relative;">
                    <span style="filter: ${char.overlay ? 'brightness(0.7)' : 'none'}; ${char.id !== 'unicorn' ? 'color: ' + char.color : ''}">${char.icon}</span>
                    ${char.overlay ? `<span style="position: absolute; right: -5px; bottom: -5px; font-size: 20px;">${char.overlay}</span>` : ''}
                </div>
                <div class="char-name">${char.name}</div>
                <div class="char-desc">${char.desc}</div>
            `;
            card.onclick = () => selectCharacter(index);
            grid.appendChild(card);
        });

        function selectCharacter(index) {
            selectedCharacter = characters[index];
            document.querySelectorAll('.character-card').forEach((card, i) => {
                card.classList.toggle('selected', i === index);
            });
        }

        function startGame() {
            // Select random enemy (different from player)
            const availableEnemies = characters.filter(c => c.id !== selectedCharacter.id);
            enemyCharacter = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];

            document.getElementById('selectScreen').classList.add('hidden');
            document.getElementById('gameHeader').style.display = 'flex';
            document.getElementById('controls').style.display = 'flex';

            // Update icons
            document.getElementById('playerIcon').textContent = selectedCharacter.icon;
            document.getElementById('enemyIcon').textContent = enemyCharacter.icon;

            initGame();
        }

        function backToSelect() {
            document.getElementById('gameOverScreen').classList.remove('show');
            document.getElementById('selectScreen').classList.remove('hidden');
            document.getElementById('gameHeader').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            gameRunning = false;
        }

        // Canvas size
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 20, 800);
            const maxHeight = Math.min(window.innerHeight - 250, 450);
            canvas.width = maxWidth;
            canvas.height = maxHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameRunning = false;
        let comboCount = 0;
        let lastHitTime = 0;
        let groundY;

        // Entities
        let player, enemy;
        const gravity = 0.6;

        // Projectiles
        let projectiles = [];

        // Effects
        let effects = [];

        function createEntity(x, charData, isPlayer) {
            return {
                x: x,
                y: 0,
                width: 60,
                height: 70,
                vx: 0,
                vy: 0,
                speed: charData.id === 'angel' ? 6 : (charData.id === 'demon' ? 4 : 5),
                jumpPower: -15,
                health: 100,
                maxHealth: 100,
                facingRight: isPlayer,
                isHit: false,
                hitTimer: 0,
                isBlocking: false,
                charData: charData,
                // Attack cooldowns
                attack1Cooldown: 0,
                attack2Cooldown: 0,
                attack3Cooldown: 0,
                isAttacking: false,
                currentAttack: 0,
                attackTimer: 0,
                // Status effects
                slowed: 0,
                burning: 0,
                // AI specific
                thinkTimer: 0,
                currentAction: 'idle',
                actionTimer: 0
            };
        }

        // Input
        const keys = {
            left: false,
            right: false,
            jump: false,
            attack1: false,
            attack2: false,
            attack3: false
        };

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (e.key === 'ArrowLeft' || key === 'a') keys.left = true;
            if (e.key === 'ArrowRight' || key === 'd') keys.right = true;
            if (e.key === 'ArrowUp' || key === 'w' || e.key === ' ') keys.jump = true;
            if (key === 'z' || e.key === '1') keys.attack1 = true;
            if (key === 'x' || e.key === '2') keys.attack2 = true;
            if (key === 'c' || e.key === '3') keys.attack3 = true;
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (e.key === 'ArrowLeft' || key === 'a') keys.left = false;
            if (e.key === 'ArrowRight' || key === 'd') keys.right = false;
            if (e.key === 'ArrowUp' || key === 'w' || e.key === ' ') keys.jump = false;
            if (key === 'z' || e.key === '1') keys.attack1 = false;
            if (key === 'x' || e.key === '2') keys.attack2 = false;
            if (key === 'c' || e.key === '3') keys.attack3 = false;
        });

        // Touch controls
        function setupButton(id, key) {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
            btn.addEventListener('mousedown', () => keys[key] = true);
            btn.addEventListener('mouseup', () => keys[key] = false);
            btn.addEventListener('mouseleave', () => keys[key] = false);
        }

        setupButton('leftBtn', 'left');
        setupButton('rightBtn', 'right');
        setupButton('jumpBtn', 'jump');
        setupButton('attack1Btn', 'attack1');
        setupButton('attack2Btn', 'attack2');
        setupButton('attack3Btn', 'attack3');

        function createEffect(x, y, text, duration = 30) {
            effects.push({ x, y, text, life: duration, maxLife: duration });
        }

        function showCombo(count) {
            const comboEl = document.getElementById('comboDisplay');
            comboEl.textContent = `${count} COMBO!`;
            comboEl.classList.remove('show');
            void comboEl.offsetWidth;
            comboEl.classList.add('show');
        }

        // Attack functions
        function performAttack(attacker, target, attackType) {
            const charData = attacker.charData;
            let damage = 0;
            let range = 0;
            let cooldown = 0;
            let effectIcon = '';
            let isProjectile = false;

            switch(attackType) {
                case 1: // Quick attack
                    damage = 8;
                    range = 70;
                    cooldown = 25;
                    effectIcon = charData.attack1;
                    break;
                case 2: // Ranged attack
                    damage = 12;
                    range = 200;
                    cooldown = 50;
                    effectIcon = charData.attack2;
                    isProjectile = true;
                    break;
                case 3: // Heavy attack
                    damage = 20;
                    range = 90;
                    cooldown = 80;
                    effectIcon = charData.attack3;
                    break;
            }

            // Character bonuses
            if (charData.id === 'demon') damage *= 1.2;
            if (charData.id === 'shadow' && Math.random() < 0.3) damage *= 2; // Critical

            attacker.isAttacking = true;
            attacker.currentAttack = attackType;
            attacker.attackTimer = 15;

            if (attackType === 1) attacker.attack1Cooldown = cooldown;
            if (attackType === 2) attacker.attack2Cooldown = cooldown;
            if (attackType === 3) attacker.attack3Cooldown = cooldown;

            if (isProjectile) {
                // Create projectile
                projectiles.push({
                    x: attacker.x + (attacker.facingRight ? 0 : attacker.width),
                    y: attacker.y + attacker.height / 2,
                    vx: attacker.facingRight ? -10 : 10,
                    width: 30,
                    height: 30,
                    damage: damage,
                    owner: attacker,
                    icon: effectIcon,
                    charData: charData
                });
            } else {
                // Melee attack
                const attackX = attacker.facingRight ?
                    attacker.x - range :
                    attacker.x + attacker.width;

                if (target.x + target.width > attackX &&
                    target.x < attackX + range &&
                    Math.abs(target.y - attacker.y) < 60) {

                    applyDamage(attacker, target, damage, effectIcon);
                }
            }

            setTimeout(() => {
                attacker.isAttacking = false;
                attacker.currentAttack = 0;
            }, 150);
        }

        function applyDamage(attacker, target, damage, effectIcon) {
            // Check if blocking
            if (target.isBlocking) {
                // Blocked! Reduce damage by 90%
                damage = Math.floor(damage * 0.1);
                target.vx = attacker.facingRight ? -3 : 3;
                createEffect(target.x + target.width/2, target.y - 20, 'üõ°Ô∏è');
                createEffect(target.x + target.width/2, target.y + 10, '‚ú®', 15);
                target.health -= damage;
                return;
            }

            target.health -= damage;
            target.isHit = true;
            target.hitTimer = 15;
            target.vx = attacker.facingRight ? -8 : 8;

            // Hit effect
            createEffect(target.x + target.width/2, target.y, effectIcon);
            createEffect(target.x + target.width/2 + 15, target.y - 10, 'üí¢', 20);

            // Status effects
            if (attacker.charData.id === 'ice') {
                target.slowed = 60;
            }
            if (attacker.charData.id === 'fire') {
                target.burning = 90;
            }

            // Combo for player
            if (attacker === player) {
                const now = Date.now();
                if (now - lastHitTime < 1500) {
                    comboCount++;
                    if (comboCount >= 2) showCombo(comboCount);
                } else {
                    comboCount = 1;
                }
                lastHitTime = now;
            } else {
                comboCount = 0;
            }

            // Angel heal on hit
            if (attacker.charData.id === 'angel' && attacker.health < attacker.maxHealth) {
                attacker.health = Math.min(attacker.health + 2, attacker.maxHealth);
            }
        }

        // AI Logic
        function updateAI() {
            // Always face the player
            enemy.facingRight = enemy.x > player.x;
            enemy.isBlocking = false;

            enemy.thinkTimer++;

            if (enemy.thinkTimer >= 20) {
                enemy.thinkTimer = 0;

                const distX = player.x - enemy.x;
                const distance = Math.abs(distX);

                // Decide action
                if (distance < 80) {
                    // Close range - sometimes block
                    if (player.isAttacking && Math.random() < 0.5) {
                        enemy.currentAction = 'block';
                    } else if (enemy.attack3Cooldown <= 0 && Math.random() < 0.3) {
                        enemy.currentAction = 'attack3';
                    } else if (enemy.attack1Cooldown <= 0) {
                        enemy.currentAction = 'attack1';
                    } else if (Math.random() < 0.4) {
                        enemy.currentAction = 'block';
                    } else {
                        enemy.currentAction = 'idle';
                    }
                } else if (distance < 200) {
                    // Medium range
                    if (enemy.attack2Cooldown <= 0 && Math.random() < 0.4) {
                        enemy.currentAction = 'attack2';
                    } else if (Math.random() < 0.6) {
                        enemy.currentAction = distX > 0 ? 'moveRight' : 'moveLeft';
                    } else {
                        enemy.currentAction = 'idle';
                    }
                } else {
                    // Far range
                    if (enemy.attack2Cooldown <= 0 && Math.random() < 0.3) {
                        enemy.currentAction = 'attack2';
                    } else {
                        enemy.currentAction = distX > 0 ? 'moveRight' : 'moveLeft';
                    }
                }

                // Random jump
                if (Math.random() < 0.1 && enemy.y >= groundY - enemy.height) {
                    enemy.vy = enemy.jumpPower;
                }

                enemy.actionTimer = 15 + Math.random() * 10;
            }

            // Execute action
            let speed = enemy.speed;
            if (enemy.slowed > 0) speed *= 0.5;

            enemy.vx = 0;

            switch (enemy.currentAction) {
                case 'moveLeft':
                    enemy.vx = -speed;
                    break;
                case 'moveRight':
                    enemy.vx = speed;
                    break;
                case 'block':
                    enemy.isBlocking = true;
                    // Move backwards while blocking
                    enemy.vx = enemy.facingRight ? speed * 0.3 : -speed * 0.3;
                    break;
                case 'attack1':
                    if (enemy.attack1Cooldown <= 0) {
                        performAttack(enemy, player, 1);
                    }
                    enemy.currentAction = 'idle';
                    break;
                case 'attack2':
                    if (enemy.attack2Cooldown <= 0) {
                        performAttack(enemy, player, 2);
                    }
                    enemy.currentAction = 'idle';
                    break;
                case 'attack3':
                    if (enemy.attack3Cooldown <= 0) {
                        performAttack(enemy, player, 3);
                    }
                    enemy.currentAction = 'idle';
                    break;
            }

            enemy.actionTimer--;
            if (enemy.actionTimer <= 0) {
                enemy.currentAction = 'idle';
            }
        }

        function updatePlayer() {
            // Always face the enemy
            player.facingRight = player.x > enemy.x;

            if (player.isHit) {
                player.hitTimer--;
                if (player.hitTimer <= 0) player.isHit = false;
                return;
            }

            let speed = player.speed;
            if (player.slowed > 0) speed *= 0.5;

            player.vx = 0;
            player.isBlocking = false;

            // Check if moving backwards (blocking)
            const movingBack = (player.facingRight && keys.right) || (!player.facingRight && keys.left);

            if (keys.left) {
                player.vx = -speed * (movingBack ? 0.5 : 1);
            }
            if (keys.right) {
                player.vx = speed * (movingBack ? 0.5 : 1);
            }

            // Set blocking if moving backwards
            if (movingBack && (keys.left || keys.right)) {
                player.isBlocking = true;
            }

            if (keys.jump && player.y >= groundY - player.height) {
                player.vy = player.jumpPower;
            }
            if (keys.attack1 && player.attack1Cooldown <= 0 && !player.isBlocking) {
                performAttack(player, enemy, 1);
                keys.attack1 = false;
            }
            if (keys.attack2 && player.attack2Cooldown <= 0 && !player.isBlocking) {
                performAttack(player, enemy, 2);
                keys.attack2 = false;
            }
            if (keys.attack3 && player.attack3Cooldown <= 0 && !player.isBlocking) {
                performAttack(player, enemy, 3);
                keys.attack3 = false;
            }
        }

        function updateEntity(entity) {
            // Cooldowns
            if (entity.attack1Cooldown > 0) entity.attack1Cooldown--;
            if (entity.attack2Cooldown > 0) entity.attack2Cooldown--;
            if (entity.attack3Cooldown > 0) entity.attack3Cooldown--;
            if (entity.slowed > 0) entity.slowed--;
            if (entity.burning > 0) {
                entity.burning--;
                if (entity.burning % 30 === 0) {
                    entity.health -= 3;
                    createEffect(entity.x + entity.width/2, entity.y - 10, 'üî•', 20);
                }
            }

            if (entity.isHit) {
                entity.hitTimer--;
                if (entity.hitTimer <= 0) entity.isHit = false;
            }

            // Physics
            entity.vy += gravity;
            entity.x += entity.vx;
            entity.y += entity.vy;

            // Ground
            if (entity.y > groundY - entity.height) {
                entity.y = groundY - entity.height;
                entity.vy = 0;
            }

            // Walls
            if (entity.x < 0) entity.x = 0;
            if (entity.x > canvas.width - entity.width) entity.x = canvas.width - entity.width;

            // Hit deceleration
            if (entity.isHit) entity.vx *= 0.85;
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx;

                // Check collision with target
                const target = p.owner === player ? enemy : player;
                if (p.x + p.width > target.x &&
                    p.x < target.x + target.width &&
                    p.y + p.height > target.y &&
                    p.y < target.y + target.height) {

                    applyDamage(p.owner, target, p.damage, p.icon);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Remove if off screen
                if (p.x < -50 || p.x > canvas.width + 50) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function drawEntity(entity) {
            ctx.save();

            const centerX = entity.x + entity.width / 2;
            const centerY = entity.y + entity.height / 2;

            // Hit state - shake and flash
            let offsetX = 0;
            let offsetY = 0;
            if (entity.isHit) {
                offsetX = (Math.random() - 0.5) * 8;
                offsetY = (Math.random() - 0.5) * 4;
                if (Math.floor(Date.now() / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
            }

            // Flip if facing left
            if (!entity.facingRight) {
                ctx.translate(centerX, 0);
                ctx.scale(-1, 1);
                ctx.translate(-centerX, 0);
            }

            // Status effect glow
            if (entity.slowed > 0) {
                ctx.shadowColor = '#54a0ff';
                ctx.shadowBlur = 20;
            }
            if (entity.burning > 0) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 20;
            }
            if (entity.isBlocking) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;
            }

            // Draw character with offset for hit shake
            ctx.font = `${entity.height}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Color filter for different unicorns
            if (entity.charData.id !== 'unicorn') {
                ctx.filter = `hue-rotate(${getHueRotation(entity.charData.id)}deg)`;
            }

            ctx.fillText(entity.charData.icon, centerX + offsetX, centerY + offsetY);
            ctx.filter = 'none';

            // Draw overlay emoji
            if (entity.charData.overlay) {
                ctx.font = '25px Arial';
                ctx.fillText(entity.charData.overlay, centerX + 15 + offsetX, centerY - 20 + offsetY);
            }

            // Blocking gesture - show shield
            if (entity.isBlocking) {
                ctx.font = '40px Arial';
                const shieldX = entity.facingRight ? entity.x - 15 : entity.x + entity.width + 15;
                ctx.fillText('üõ°Ô∏è', shieldX, centerY);
            }

            // Attack gesture
            if (entity.isAttacking && entity.currentAttack > 0) {
                ctx.font = '35px Arial';
                const attackIcon = entity.currentAttack === 1 ? entity.charData.attack1 :
                                   entity.currentAttack === 2 ? entity.charData.attack2 :
                                   entity.charData.attack3;
                const attackX = entity.facingRight ? entity.x - 25 : entity.x + entity.width + 25;
                ctx.fillText(attackIcon, attackX, centerY);

                // Attack motion lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                const lineX = entity.facingRight ? entity.x - 40 : entity.x + entity.width + 40;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(lineX + (entity.facingRight ? 15 : -15), centerY - 15 + i * 15);
                    ctx.lineTo(lineX, centerY - 15 + i * 15);
                    ctx.stroke();
                }
            }

            // Hit gesture - show pain
            if (entity.isHit) {
                ctx.font = '25px Arial';
                ctx.fillText('üí¢', centerX + 25, centerY - 30);
                ctx.fillText('üòµ', centerX - 25, centerY - 35);
            }

            ctx.restore();
        }

        function getHueRotation(charId) {
            switch(charId) {
                case 'demon': return 300;
                case 'angel': return 60;
                case 'ice': return 180;
                case 'fire': return 330;
                case 'shadow': return 240;
                default: return 0;
            }
        }

        function draw() {
            // Background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#2d1b4e');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ground
            ctx.fillStyle = '#3d3d5c';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            ctx.strokeStyle = '#5d5d8c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();

            // Draw entities
            drawEntity(player);
            drawEntity(enemy);

            // Draw projectiles
            projectiles.forEach(p => {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.icon, p.x + p.width/2, p.y + p.height/2);
            });

            // Draw effects
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                ctx.globalAlpha = effect.life / effect.maxLife;
                ctx.font = '35px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(effect.text, effect.x, effect.y - (effect.maxLife - effect.life) * 1.5);
                ctx.globalAlpha = 1;

                effect.life--;
                if (effect.life <= 0) effects.splice(i, 1);
            }

            // Update health bars
            document.getElementById('playerHealth').style.width =
                `${Math.max(0, (player.health / player.maxHealth) * 100)}%`;
            document.getElementById('enemyHealth').style.width =
                `${Math.max(0, (enemy.health / enemy.maxHealth) * 100)}%`;

            // Update cooldown buttons
            document.getElementById('attack1Btn').classList.toggle('cooldown', player.attack1Cooldown > 0);
            document.getElementById('attack2Btn').classList.toggle('cooldown', player.attack2Cooldown > 0);
            document.getElementById('attack3Btn').classList.toggle('cooldown', player.attack3Cooldown > 0);
        }

        function checkGameOver() {
            if (player.health <= 0) {
                gameRunning = false;
                document.getElementById('resultIcon').textContent = enemyCharacter.icon;
                document.getElementById('resultText').textContent = 'Ìå®Î∞∞...';
                document.getElementById('resultText').className = 'result-text lose';
                document.getElementById('gameOverScreen').classList.add('show');
            } else if (enemy.health <= 0) {
                gameRunning = false;
                document.getElementById('resultIcon').textContent = selectedCharacter.icon;
                document.getElementById('resultText').textContent = 'ÏäπÎ¶¨!';
                document.getElementById('resultText').className = 'result-text win';
                document.getElementById('gameOverScreen').classList.add('show');
            }
        }

        function gameLoop() {
            if (!gameRunning) return;

            updatePlayer();
            updateAI();
            updateEntity(player);
            updateEntity(enemy);
            updateProjectiles();

            draw();
            checkGameOver();

            requestAnimationFrame(gameLoop);
        }

        function initGame() {
            groundY = canvas.height - 50;

            player = createEntity(100, selectedCharacter, true);
            player.y = groundY - player.height;

            enemy = createEntity(canvas.width - 160, enemyCharacter, false);
            enemy.y = groundY - enemy.height;
            enemy.facingRight = false;

            projectiles = [];
            effects = [];
            comboCount = 0;
            lastHitTime = 0;

            gameRunning = true;
            gameLoop();
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.remove('show');

            // Random new enemy
            const availableEnemies = characters.filter(c => c.id !== selectedCharacter.id);
            enemyCharacter = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
            document.getElementById('enemyIcon').textContent = enemyCharacter.icon;

            initGame();
        }
    </script>
</body>
</html>
